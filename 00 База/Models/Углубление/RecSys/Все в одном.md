Стажерский набор

### Данные

Сбор данных:
- Explicit feedback - умышленно (рейтинг, лайк, репост)
- Implicit feedback - на бекграунде (время просмотра, клики, история и т.п.)

Тип хранение:
- SQL или NoSQL или любые другие бдшечки. Можно использовать Redis для сохранения предсказаний 

### Рекомендательные системы:

##### **Collaborative Filtering** (User-based, Item-based)

Разделяется на 2 типа, User-based и Item-based

- **User-based:**
Построенно на схожести пользователей (если у меня и у другого человека много совпадений, то мне могут предложить то, что смотрел он, но не смотрел я)

**Cosine similarity, Pearson correlation**
**K-nearest neighbors**
**Weighted average**

- **Item-based:**
Этот метод предсказывает одинаковые предметы основанные на предыдущих оценках объектов.

**Cosine similarity**
**Adjusted cosine similarity**


Collaborative Filtering страдает от 3 основных проблем:
1. Cold start - что предлагать новым, только зарегистрированным пользователям
2. Масштабируемость - с ростом пользователей и объектов, становится сложнее высчитывать рекомендации.
3. Sparsity - пользователи в основном оценивают только очень малую часть объектов из имеющихся, из-за чего много пустых значений

##### **Content-based filtering**

Построено на атрибутах продукта (жанры, одинаковые артикли и т.п.) и предпочтениях пользователя (любит хорроры - получит чаще их)

Здесь тоже выделяются 3 проблемы:
- Filter Bubble - рекомендует только похожее
- Limited Discovery - нет неожиданных находок
- Feature Engineering - нужно извлекать как-то признаки

TF-IDF + Cosine similarity
Feature-Based Similarity
User profile Building

##### **Matrix Factorization** (SVD, ALS)
- SVD

Explicit feedback (от 1 до 5 например)
Меньше памяти доступно
Online learning
Работает на SGD
Обновляет каждый рейтинг отдельно
Медленно сходится
Может застрять в локальном минимуме
Для Implicit feedback нужна модификация до SVD++
Biases явно моделируются

- ALS

Особенно популярен для implicit feedback.

Подходит для implicit feedback, больших датасетов, batch processing, collaborative filt.
Преимущества: масштабируется, работает с разреженными данными, determenistic.
Проблемы: Real-time, Content-based, Cold-start, Memory intensive, Linear complexity

##### **Метрики оценки**: Precision@K, Recall@K, NDCG, MAP

Precision@K = relevant_items_in_top_k/k
Recall@K = relevant_items_in_top_k/total_relevant_items

``` python
dcg_k = sum(rel_i / log2(i + 1) for i in range(k))
ndcg_k = dcg_k / ideal_dcg_k
```

##### **Cold start problem** и способы его решения

Разделяется на три типа:
- New User Cold Start - данных о пользователе нет, поэтому мы не знаем, что ему предложить.
- New Item Cold Start - объект никто еще не трогал, поэтому мы не знаем, кому может понравиться.
- New System Cold Start - ваще никаких данных нет

Как решать эти проблемы?
Новым пользователям можно предлагать популярные фильмы (items) в регионе, проводить опрос при регистрации для поиска любимых жанров и т.п. Можно еще импортировать данные из других сервисов, что поможет базово понять, что рекомендовать.

Подходы:
1. Popularity-based. Простые и всегда работают, но не персонализированы, имеют проблему filter bubble.
2. Demographic-based. Используем данные о самом пользователе по типу возраста, пола, локации, профессии, гаджетов и т.п.
3. Content-based. Собираем любым способом информацию о пользователе: explicit, implicit feedback. И импорт из других сервисов.
4. Knowledge-based. Основывается на внешней информации (в основном не зависит от пользователя напрямую) по типу сезонности, отелей по бюджету и локации, по недавним новостям.
5. Hybrid. Комбинирует несколько способов в одну. Просто перемешивает и дает какой-то вес определенным системам. Например, 0.3 на demographic-based, 0.4 на popularity-based, 0.3 на content-based. 

### RAG пайплайны (базово):

- Понимание концепции **Retrieval-Augmented Generation**
- **Vector databases** (FAISS, Pinecone) - что это и зачем
- **Embeddings** для текста и их применение
- **Chunking strategies** для документов

