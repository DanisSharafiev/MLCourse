Сейчас поговорим о том, как обычные математические преобразования являются частью Feature Engineering.

### Сумма и разность

Допустим, проходят матчи в игре 2х2. Каждый игрок собирает очки, и они записываются только к нему на счет. Мы должны предсказать выиграет команда 0 или 1.

``` python
import pandas as pd

data = {
    'player1_points': 15,
    'player2_points': 10,
    'player3_points': 20,  
    'player4_points': 18, 
    'team_winner': 1  
}

df = pd.DataFrame(data)
```

С помощью суммы мы можем посчитать сколько заработала команда за матчи.

``` python
df['team0_total'] = df['player1_points'] + df['player2_points']
df['team1_total'] = df['player3_points'] + df['player4_points']
```

Если бы не было данных об одном игроке, тогда можно было высчитать с помощью разницы:

``` python
df['player1_points'] = df['team0_total'] - df['player2_points']
```

### Деление и умножение

Для наглядности добавим сколько игр сыграла каждая команда:

``` python
df['team0_games_played'] = 1
df['team1_games_played'] = 2
```

Если бы мы учитывали только total, одна команда могла набрать 300 очков за одну игру, а другая - 300 за 20 игр. Для того, чтобы понять, сколько в среднем зарабатывает команда за игру просто поделили на количество игр.

``` python
df['team0_avg'] = df['team0_total'] / df['team0_games_played']
df['team1_avg'] = df['team1_total'] / df['team1_games_played']
```

Условно, если бы у нас не было team0_total, мы бы могли его получить через умножение:

``` python
df['team1_total'] = df['team1_games_played'] * df['team1_avg']
```

### Нелинейные зависимости

Доступны самые разные операции по типу степеней, логарифмирования, корней, модулей и такого же подобного.
Тут придется выбирать в зависимости от разных задач. Думаю, что в такое чаще встречается в физике, химии в сложных формулах, которые можно брать как признак для моделей.
