# Как валидировать данные?

Про уже готовые DataFrames я не собираюсь говорить в этой части конспекта, т.к. есть еще глава Data Wrangling. Тем не менее, здесь мы рассмотрим pydantic, т.к. основная часть информации приходит из API, а pydantic очень приятно помогает с валидацией.

# Pydantic

Покрою самые базовые кейсы, начнем с того, что импортируем FastAPI, т.к. к нам будут приходить уже валидированные данные.

``` python
from fastapi import FastAPI

app = FastAPI()
```

В FastAPI можно подавать классы построенные от BaseModel из pydantic. Покажу сразу супер простой пример того, как их строят.

``` python
from pydantic import BaseModel, HttpUrl
from typing import List, Literal, Tuple

class Example(BaseModel):
    list_of_ints: List[int]
    union_of_int_and_str: int | str
    literal: Literal["foo", "bar"]
    website: HttpUrl
    tuple_: Tuple[int, str, float]
```

Здесь четко показан способ создавать классы через BaseModel. 
- List\[int] обозначает список, в котором должны содержаться исключительно int значения
- int | str говорит о том, что значение должно быть либо int, либо str
- Literal по факту представляет собой классификацию между foo и bar
- HttpUrl принимает в себя только строки, которые подходят под url
- Tuple\[int, str, float] - это tuple, где определенные переменные расположены в определенном порядке.

Теперь думаю стоит рассмотреть, как мы можем валидировать данные по определенным условиям. Разделяю это на два класса: без помощи декораторов, и с их помощью (Декоратор грубо говорят запускает какую-то функцию внутри другой функции).

### Без декораторов

Рассмотрим пример:

``` python
from pydantic import EmailStr, Field
class BodyBuilder(BaseModel):
    name: str = Field(min_length=3, max_length=50)
    age: int = Field(ge=0, le=120)
    email: EmailStr
    is_rich: bool = False
    number_of_children: int | None = None
```

